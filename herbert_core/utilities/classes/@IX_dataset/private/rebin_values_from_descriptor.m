function xout = rebin_values_from_descriptor (xdescr, is_boundaries,...
    varargin)
% Get new x values from a bin boundary descriptor
%
% If no retained input values and descriptor ranges are all finite:
%   >> xout = rebin_values_from_descriptor (xdescr, is_boundaries)
%
%   >> xout = rebin_values_from_descriptor (xdescr, is_boundaries, tol)
%
% General case:
%   >> xout = rebin_values_from_descriptor (xdescr, is_boundaries,...
%                                                       xref, ishist)
%
%   >> xout = rebin_values_from_descriptor (xdescr, is_boundaries,...
%                                                       xref, ishist, tol)
%
% Input:
% ------
%   xdescr          Binning descriptor with the following form:
%
%         [x1, dx1, x2, dx2, x3,...xn]
%               where -Inf <= x1 < x2 < x3...< xn <= Inf  (n >= 2), and
%
%               dx +ve: equal bin sizes between corresponding limits
%               dx -ve: logarithmic bins between corresponding limits
%                      (note: if dx1<0 then x1>0, dx2<0 then x2>0 ...)
%               dx=0  : retain existing bins between corresponding limits
%
%   is_boundaries   Logical flag:
%                    - true if xdescr defines bin boundaries
%                    - false if xdescr defines bin centres
%                  [Note that -Inf and Inf always end up defining bin
%                   boundaries. The value of is_boundaries is a statement
%                   about the finite values of [x1,] x2, x3... that appear
%                   in the descriptor]
%
%   xref            Reference axis values.
%                    - If bin boundaries then there will be at least two
%                      values and with bin widths greater than zero (i.e.
%                      the values are strictly monotonic increasing)
%                    - If bin centres, then they will be monotonic
%                      increasing, but there may be repeated values, which
%                      corresponds to two or more data points that have the
%                      same position along the axis.
%
%   ishist          Logical flag:
%                    - true if xref defines bin boundaries
%                    - false if xref defines bin centres
%
%   tol             Tolerance: smallest difference between values and end
%                   points as a fraction of the penultimate spacings
%                   at each limit. Prevents overly small extremal bins from
%                   being created.
%                       tol >= 0;    default = 1e-10
%
% Output:
% --------
%   xout            Bin boundaries for rebin array (row vector)
%               It is possible to end up with just two bin boundaries whose
%               values are the same (for example, descriptor is [5,0,Inf]
%               and xref = [5,5,5] i.e. point data where all points have
%               the same position along the axis).


% How the algorithm works
% -----------------------
% Overview:
%         [x1, dx1, x2, dx2, x3,...xn]
%               where -Inf <= x1 < x2 < x3...< xn <= Inf  (n >= 2)
%
% The descriptors define bin boundaries or bin centres according to the
% value of is_boundaries.
%
% Inf and -Inf are resolved into the extremes of the data, that is
% xn = xref(end) and x1 = xref(1), regardless of whether xref originates
% from point data, or defines bin centres or bin boundaries for histogram
% data. That is because these are the true extremes of the data.
%
% The values defined by each descriptor block  [x(m), dx(m), x(m+1)] that
% satisfy x(m) < {x} < x(m+1) are accumulated into the output array xout, 
% interleaved by the terminal values for the blocks x2, x3...x(n-2),
% x(n-1). The first and last values of xout are set to the original values
% of x1 and xn, that is, if x1 was -Inf it will be set to that in xout 
% rather than the resolved value xref(1).
%
% The final resolution of xout (converting bin centres to boundaries if
% is_boundaries is false, and handling -Inf &/or Inf as the extremal
% values) needs to be performed by the function 
% rebin_boundaries_from_values. This ensures complete consistency of the
% treatment of values generated by this function and the case when rebin
% methods are passed x-values directly.


% Parse input arguments
narg = numel(varargin);
if narg==1 || narg==3
    tol = varargin{end};
else
    tol = 1e-10;    % default
end

if narg==2 || narg==3
    xref = varargin{1};
    ishist = varargin{2};
elseif narg>3
    error('HERBERT:rebin_values_from_descriptor:invalid_argument',...
        'Too many input arguments');
end


% Convert reference bin boundaries to centres, or vice versa, if required
del_array = xdescr(2:2:end);
if any(del_array==0)
    if ~ishist
        % We need to find unique values of the reference array. While it is
        % monotonic increasing (by supposition), it may have repeated x
        % values if it originates from true point data as opposed to bin
        % centres of a histogram.
        %
        % If there is only one unique point value; retain this as a single
        % value as cannot have a final output set of bin boundaries where
        % there are two equal bin boundaries.
        if is_boundaries
            % Descriptor is of bin boundaries, and the reference data is bin
            % centres or points. However, there is at least one interval that
            % needs to be filled with reference bin boundaries; therefore we
            % need to generate bin boundaries from the reference bin centres
            % or point data.
            %
            % If there is only one unique point value; retain this as a single
            % value as cannot have a final output set of bin boundaries where
            % there are two equal bin boundaries.
            xref_unique = xref([true, diff(xref)~=0]);
            if numel(xref_unique)==1
                xref_tmp = xref_unique;
            else
                xref_tmp = bin_boundaries (xref_unique);
            end
        else
            % Descriptor is for bin centres, so just need to retain unique
            % values
            xref_tmp = xref([true, diff(xref)~=0]);
        end
        
    else
        if ~is_boundaries
            % Descriptor is of bin centres, and the reference data is bin
            % boundaries. However, there is at least one interval that
            % needs to be filled with reference bin centres; therefore we
            % need to generate bin centres from the reference bin boundaries.
            xref_tmp = bin_centres (xref);  % OK as numel(xref)>=2 by supposition
            
        else
            % Use xref unchanged
            xref_tmp = xref;
        end
    end
end


% Loop over the descriptor intervals. On first pass accumulate the number
% of points in each interval. On the second pass assign the output array
% now that the total number of points is known, and then fill the output
% array.

nout_filled = false;
xout_allocated = false;

while ~xout_allocated
    % Pre-assign x_out once the size has been calculated
    if nout_filled
        xout = zeros(1,nout);
        xout_allocated = true;
    end
    
    % Loop over the intervals
    ntot = 0;	% total number of values in output array so far
    ndescr = floor(numel(xdescr)/2);    % number of descriptor intervals
    for i = 1:ndescr
        % Get the lower and upper limits of the descriptor interval, and
        % the step size.
        % In the case of intervals where one or both bounds is infinite
        % the limits are resolved as being the range of the data. These are
        % the extremal bin boundaries in the case of histogram data, or the
        % extremal x coordinates in the case of point data, regardless of
        % whether the descriptor is of bin boundaries or bin centres.
        
        % Get xlo, del, xhi for descriptor interval [xlo,del,xhi]
        first_and_Inf = (i==1 && isinf(xdescr(1)));
        if first_and_Inf
            % Case that first descriptor starts with -Inf
            xlo = xref(1);
        else
            xlo = xdescr(2*i-1);
        end
        
        del = xdescr(2*i);
        
        last_and_Inf = (i==ndescr && isinf(xdescr(end)));
        if last_and_Inf
            % Case that last descriptor ends with Inf
            xhi = xref(end);
        else
            xhi = xdescr(2*i+1);
        end
        
        % Get origin for values, and set the interval as being open
        % The end points of the descriptor intervals will be interleaved
        % explicitly.
        if first_and_Inf && last_and_Inf
            if is_boundaries
                type = '(c0)';
            else
                type = '(v0)';
            end
        elseif first_and_Inf
            type = '(x2)';
        else
            type = '(x1)';
        end
        
        % Increment ntot to hold lower limit of the interval
        if xout_allocated
            if first_and_Inf
                xout(ntot+1) = -Inf;
            else
                xout(ntot+1) = xlo;
            end
        end
        ntot = ntot + 1;
        
        % Get the values
        if del > 0
            % Equally spaced bins
            np = values_equal_steps (xlo, del, xhi, type, tol);
            if xout_allocated
                [~, xout(ntot+1:ntot+np)] = values_equal_steps (...
                    xlo, del, xhi, type, tol);
            end
            ntot = ntot + np;
            
        elseif del < 0
            % Logarithmic bins
            np = values_logarithmic_steps (xlo, abs(del), xhi, type, tol);
            if xout_allocated
                [~, xout(ntot+1:ntot+np)] = values_logarithmic_steps (...
                    xlo, abs(del), xhi, type, tol);
            end
            ntot = ntot + np;
            
        else
            % Retain existing bins
            np = values_contained_points (xlo, xref_tmp, xhi, type([1,4]), tol);
            if xout_allocated
                [~, xout(ntot+1:ntot+np)] = values_contained_points (...
                    xlo, xref_tmp, xhi, type([1,4]), tol);
            end
            ntot = ntot + np;
        end
        
        % Increment ntot to hold upper limit of the final interval
        if i==ndescr
            if xout_allocated
                if isinf(xdescr(end))
                    xout(ntot+1) = Inf;
                else
                    xout(ntot+1) = xhi;
                end
            end
            ntot = ntot + 1;
        end
        
    end
    
    if ~nout_filled
        % Store the size of the output array
        nout = ntot;
        nout_filled = true;
    end
    
end
