classdef hlp_serial_types
    
    properties(Constant)
        % Names to numbers
        types = {'logical', 'char', 'string', 'double',...
            'single', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',...
            'int64', 'uint64', 'complex_double', 'complex_single', 'complex_int8',...
            'complex_uint8', 'complex_int16', 'complex_uint16', 'complex_int32',...
            'complex_uint32', 'complex_int64', 'complex_uint64', 'cell', 'struct',...
            'function_handle', 'value_object', 'handle_object_ref', 'enum',...
            'sparse_logical', 'sparse_double', 'sparse_complex_double',...
            'serializable'};
        
        lookup = containers.Map(hlp_serial_types.types,1:33);
        
        % Details associated with type
        type_details = struct('name',...
            hlp_serial_types.types,...
            'size',... % Sizes of respective data types
            {1, 1, 2, 8,...          %      'logical', 'char', 'string', 'double',...
            4, 1, 1, 2, 2, 4, 4,...  %      'single', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',...
            8, 8, 16, 8, 2, ...      %      'int64', 'uint64', 'complex_double', 'complex_single', 'complex_int8',...
            2, 4, 4, 8,...           %      'complex_uint8', 'complex_int16', 'complex_uint16', 'complex_int32',...
            8, 16, 16, 0, 0, ...     %      'complex_uint32', 'complex_int64', 'complex_uint64', 'cell', 'struct',...
            0, 0, 0, 0, ...          %      'function_handle', 'value_object', 'handle_object_ref', 'enum',...
            1, 8, 16,...             %      'sparse_logical', 'sparse_double', 'sparse_complex_double'
            0},...                   %      'serializable' -- object serializes itself
            'tag',... % Lookup tags for type of serialised data,
            cellfun(@uint8, num2cell(0:32), 'UniformOutput', false));
        
        func_handle_types ={'simple', 'classsimple','anonymous','scopedfunction','nested'}
        func_handle_tags  ={ 1            1              2           3             3}
        fh_map = containers.Map(hlp_serial_types.func_handle_types ,...
            hlp_serial_types.func_handle_tags)
        
        
        tag_size = 2;  % Size of standard tag (uint8) in bytes
        ndims_size = 1;% Size of standard num dimensions (uint8) in bytes
        dim_size = 4;  % Size of standard dimension (uint32) in bytes
        %dims_tag = uint8([32 64 96 128 160 192 224]); % Dims tags to set number of dimensions
    end
    
    methods(Static)
        function details = get_details(type)
            details = hlp_serial_types.type_details(hlp_serial_types.lookup(type));
        end
        function tag = dims_tag(nDims)
            tag  = uint8(nDims);
        end
        %
        function size = get_size(type)
            size = hlp_serial_types.type_details(hlp_serial_types.lookup(type)).size;
        end
        
        function cont = contains(type)
            cont = isKey(hlp_serial_types.lookup, type);
        end
        
        function objID_struc = type_mapping(v)
            type = class(v);
            if isa(v,'serializable')
                objID_struc = hlp_serial_types.get_details('serializable');
                return
            end
            
            if isnumeric(v) && ~isreal(v)
                type = ['complex_' type];
            end
            if issparse(v)
                type = ['sparse_' type];
            end
            
            if isKey(hlp_serial_types.lookup, type)
                objID_struc = hlp_serial_types.get_details(type);
            elseif ishandle(v)
                objID_struc = hlp_serial_types.get_details('handle_object');
            else
                objID_struc = hlp_serial_types.get_details('value_object');
            end
        end
        %
        function [type_str, nDims,size,pos] = unpack_data_tag(head_bytes,pos)
            % unpack data tag, previously generated by pack_data_tag
            % function
            type_str = hlp_serial_types.type_details(head_bytes(pos)+1);
            nDims = double(head_bytes(pos+1));
            pos = pos + 2;
            if strcmp(type_str.name,'function_handle')
                % ndims is actually the function additional tag and the
                % size is not used
                size = [];
            else
                if nDims == 0
                    size = [];
                elseif nDims == 1
                    nElem = double(typecast(head_bytes(pos:pos+3), 'uint32'));
                    size = [1,nElem];
                    pos = pos+4;
                else
                    nBytes = nDims*4;
                    size   = double(typecast(head_bytes(pos:pos+nBytes-1), 'uint32')');
                    pos    = pos+nBytes;
                end
            end
        end
        %
        function comb_tag = pack_data_tag(data_size,type_struc,varargin)
            % Pack tag data into different size bytestring, with actual
            % size depending on the size and shape of the data
            
            nDims = numel(data_size);
            if isempty(data_size)
                nElem = 0;
            else
                nElem = prod(data_size);
            end
            if strcmp(type_struc.name,'function_handle') %
                comb_tag = [type_struc.tag;hlp_serial_types.fh_map(varargin{1})];
            else
                if nElem == 0
                    comb_tag = [type_struc.tag;hlp_serial_types.dims_tag(0)];
                elseif nElem == 1 % avoid writing 2 dimensions for scalars
                    comb_tag = [type_struc.tag;hlp_serial_types.dims_tag(1);...
                        typecast(uint32(1),'uint8')'];
                elseif nDims == 2 && data_size(1) == 1 % some saving in writing rows
                    %  assuming 2D arrays are always rows. If this incorrect,
                    %  use general case
                    comb_tag = [type_struc.tag;hlp_serial_types.dims_tag(1);...
                        typecast(uint32(nElem),'uint8')'];
                else
                    comb_tag = [type_struc.tag;hlp_serial_types.dims_tag(nDims);...
                        typecast(uint32(data_size),'uint8')'];
                end
            end
        end
        function tag_size = calc_tag_size(data_size,type_struc,varargin)
            % find size of a data tag depending on the size and shape of the data
            
            nDims = numel(data_size);
            if isempty(data_size)
                nElem = 0;
            else
                nElem = prod(data_size);
            end
            if strcmp(type_struc.name,'function_handle') %
                tag_size = hlp_serial_types.tag_size;
            else
                if nElem == 0
                    tag_size = hlp_serial_types.tag_size;
                elseif nElem == 1 % avoid writing 2 dimensions for scalars
                    tag_size = hlp_serial_types.tag_size+4;
                elseif nDims == 2 && data_size(1) == 1 % some saving in writing rows
                    % assuming 2D arrays are always rows
                    tag_size = hlp_serial_types.tag_size+4;
                else
                    tag_size = hlp_serial_types.tag_size+4*numel(data_size);
                end
            end
        end
        
    end
    
end