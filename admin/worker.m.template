function ok=worker(worker_controls_string)
% function used as standard worker to do a job in different Matlab
% session.
%
% To work, should be present on a data search path, before Herbert is
% initialized as may need to initialize Herbert and Horace itself
%
%Inputs:
% worker_controls_string - the structure, containing information, necessary to
%              initiate the job.
%              Due to the fact this string is transferred
%              through pipes its size is system dependent and limited, so
%              contains only minimal initialization information, namely the
%              folder name where the job initialization data are located on
%              a remote system
%
%
%
if isempty(which('herbert_init.m'))
    horace_on();
end
% Check current state of mpi framework and set up deployment status
% within Matlab code to run
mis = MPI_State.instance();
mis.is_deployed = true;
is_tested = mis.is_tested; % set up to tested state within unit tests.
%
% for testing we need to recover 'not-deployed' state to avoid clashes with
% other unit tests. The production job finishes Matlab and clean-up is not necessary
% though doing no harm.
clot = onCleanup(@()(setattr(mis,'is_deployed',false)));



control_struct = iMessagesFramework.deserialize_par(worker_controls_string);
% Initalize config files to use on remote session
%
% remove configurations, may be loaded in memory while horace was
% initialized.
config_store.instance('clear');
% Where config files are stored:
config_exchange_folder = fullfile(control_struct.data_path,config_store.config_folder_name);
% set pas to config sources:
config_store.set_config_folder(config_exchange_folder);
% instantiate filebasedMessages framework, used to transfer initial data,
% exchange messages between head node and workers pool and display log
% information
fbMPI = FilebasedMessages(control_struct);
% initiate file-based framework to exchange messages between head node and
% the pool of workers
try
    worker_init_data = fbMPI.receive_job_info('','-keep');
catch ME
    mess = aMessage('failed');
    mess.payload = sprintf('job N%s failed while receive_job_info Error: %s:',...
        control_struct.jobID,ME.message);
    fbMPI.send_message(mess);
    ok = MESS_CODES.runtime_error;
    return;
end
exit_at_the_end = ~is_tested && worker_init_data.exit_on_compl;
%
% receive init message which defines the job parameters
% should block execution until this message is received.
[ok,err,init_message] = fbMPI.receive_message(0,'init');
if ok ~= MESS_CODES.ok
    error('WORKER:init_worker',err);
end

% instantiate job executor class.
je = feval(worker_init_data.JobExecutorClassName);
% Attach jobExecutor methods to mpi singleton to be availible from any part
% of the code.
mis.logger = @(step,n_steps,time,add_info)...
    (je.log_progress(step,n_steps,time,add_info));

mis.check_cancelled = @()(f_canc(je));
%mis.mpi_framework = je.mess_framework;

try
    je = je.init(fbMPI,control_struct,init_message);
    % Execute job (run main job executor's do_job method
    while ~je.is_completed()
        je= je.do_job();
        je = je.reduce_data();
    end
    ok = MESS_CODES.ok;
catch ME
    ok = MESS_CODES.runtime_error;
    if ~strcmpi(ME.identifier,'MESSAGE_FRAMEWORK:cancelled')
        
        mess = aMessage('failed');
        mess.payload = {sprintf('job N%d failed at do_job method. Reason: %s',...
            fbMPI.labIndex,ME.message),ME};
        fbMPI.send_message(0,mess);
    else
        if exit_at_the_end
            exit;
        else
            return
        end
    end
    if exit_at_the_end
        exit;
    else
        rethrow(ME)
    end
end
%
je.finish_task();
%pause
if exit_at_the_end
    exit;
end

function f_canc(job_executor)
if job_executor.is_job_cancelled()
    error('MESSAGE_FRAMEWORK:cancelled',...
        'Messages framework has been cancelled or not initialized any more')
end

