function ok=worker(class_name,job_controls_string)
% function used as standard worker to do a job in different Matlab
% session.
%
% To work, should be present on a data search path, before Herbert is
% initialized as may need to initialize Herbert and Horace itself
%
%Inputs:
% class_name -- the name of the class, which do the job. The class
%               should inherit from JobExecutor and overload
%               do_job method. Other methods used by this worker should remain
%               untouched (unless you understand what you are doing.)
%
% job_controls_string - the structure, containing information, necessary to
%              initiate job.
%
%
if isempty(which('herbert_init.m'))
    horace_on();
end
% Check current state of mpi framework and set up deployment status

mis = MPI_State.instance();
mis.is_deployed = true;
is_tested = mis.is_tested; % set up to tested state within unit tests.
%
% for testing we need to recover 'not-deployed' state to avoid clashes with
% other unit tests. The production job finishes Matlab and clean-up is not necessary
% though doing no harm.
clot = onCleanup(@()(setattr(mis,'is_deployed',false)));

% instantiate worker class.
je = feval(class_name);

[je,job_arguments,job_controls,err_mess]=je.init_worker(job_controls_string);

exit_at_the_end = ~is_tested && job_controls.exit_on_compl;
if ~isempty(err_mess)
    % clear all existing messages for this job
    je.receive_all_messages();
    
    mess = aMessage('failed');
    mess.payload = sprintf('job N%d failed at init_worker. Reason: %s',...
        je.task_id,err_mess);
    je.send_message(mess);
    ok = false;
    if exit_at_the_end
        exit;
    else
        error('WORKER:init_worker',mess.payload)
    end
else
    ok = true;
end
%
mis.logger = @(step,n_steps,time,add_info)...
    (je.log_progress(step,n_steps,time,add_info));

mis.check_cancelled = @()(f_canc(je));
mis.mpi_framework = je.mess_framework;
%
% Execute job (run main job executor's do_job method
try
    if iscell(job_arguments)
        je = je.do_job(job_arguments{:});
    else
        je = je.do_job(job_arguments);
    end
    ok = true;
catch ME
    ok = false;
    if ~strcmpi(ME.identifier,'MESSAGE_FRAMEWORK:cancelled')
        % clear all existing messages for this job
        je.receive_all_messages();
        
        mess = aMessage('failed');
        mess.payload = {sprintf('job N%d failed at do_job method. Reason: %s',...
            je.task_id,ME.message),ME};
        je.send_message(mess);
    end
    if exit_at_the_end
        exit;
    else
        error('WORKER:do_job',mess.payload)
    end
end
%
je.finish_job();
%pause
if exit_at_the_end
    exit;
end

end

function f_canc(job_executor)
if job_executor.is_job_cancelled()
    error('MESSAGE_FRAMEWORK:cancelled',...
        'Messages framework has been cancelled or not initialized any more')
end
end
