classdef test_parse_arguments < TestCaseWithSave
    % Test of parse_arguments
    
    methods
        %--------------------------------------------------------------------------
        function self = test_parse_arguments (name)
            self@TestCaseWithSave(name);
            
            self.save()
        end
        
        %--------------------------------------------------------------------------
        function test_1 (self)
            % Straightforward use, with 'noflag'
            
            opt = [];   % Use default options everywhere
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                'back', [15000,19000], 'mod','nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_2  (self)
            % Try to set a flag to an invalid value
            % Should throw an error
            
            opt = [];   % Use default options everywhere
            try
                [par, keyval, present, filled] = my_func_1 (opt,...
                    'input_file.dat', 18, {'hello','tiger'},...
                    'back', [15000,19000], 'mod','invalid_value','nonorm');
            catch ME
                return
            end
        end
        
        %--------------------------------------------------------------------------
        function test_3 (self)
            % Numbered required and optional parameters
            
            opt = [];   % Use default options everywhere
            [par, keyval, present, filled] = my_func_2 (2,4,opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                'back', [15000,19000], 'mod','nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_4  (self)
            % Numbered required and optional parameters but call inconsistent
            % Should throw an error
            
            opt = [];   % Use default options everywhere
            try
                [par, keyval, present, filled] = my_func_2 (2,0,opt,...
                    'input_file.dat', 18, {'hello','tiger'},...
                    'back', [15000,19000], 'mod','invalid_value','nonorm');
            catch ME
                return
            end
        end
        
        %--------------------------------------------------------------------------
        function test_5  (self)
            % Numbered required and optional parameters but call inconsistent
            % Should throw an error
            
            opt = [];   % Use default options everywhere
            try
                [par, keyval, present, filled] = my_func_2 (2,1,opt,...
                    'input_file.dat', 18, {'hello','tiger'}, [true, false],...
                    'back', [15000,19000], 'mod','invalid_value','nonorm');
            catch ME
                return
            end
        end
        
        %--------------------------------------------------------------------------
        function test_6 (self)
            % Named required and optional parameters
            
            opt = [];   % Use default options everywhere
            par_req = {'x', 'y'};
            par_opt = struct('op1', [], 'op2', [], 'op3', 14);
            [par, keyval, present, filled] = my_func_2 (par_req, par_opt, opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                'back', [15000,19000], 'mod','nonorm');
            
            par_ref.x = 'input_file.dat';
            par_ref.y = 18;
            par_ref.op1 = {'hello','tiger'};
            par_ref.op2 = [];
            par_ref.op3 = 14;
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'x',true,...
                'y',true,...
                'op1',true,...
                'op2',false,...
                'op3',false,...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'x',true,...
                'y',true,...
                'op1',true,...
                'op2',false,...
                'op3',true,...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_7  (self)
            % Named required and optional parameters but call inconsistent as
            % too many positional parameters.
            % Should throw an error
            
            opt = [];   % Use default options everywhere
            par_req = {'x', 'y'};
            par_opt = struct('op1', [], 'op2', [], 'op3', 14);
            try
                [par, keyval, present, filled] = my_func_2 (par_req, par_opt, opt,...
                    'input_file.dat', 18, {'hello','tiger'},false, {'banana'}, [13,14],...
                    'back', [15000,19000], 'mod','invalid_value','nonorm');
            catch ME
                return
            end
        end
        
        %--------------------------------------------------------------------------
        function test_8 (self)
            % Straightforward use, with 'noflag', testing prefix
            % Demand use of prefix
            
            opt.prefix = '-';
            opt.prefix_req = true;
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                '-back', [15000,19000], '-mod','-nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_9  (self)
            % Straightforward use, with 'noflag', testing prefix
            % Demand use of prefix, but supply keyword argument without it
            % Should throw an error
            
            opt.prefix = '-';
            opt.prefix_req = true;
            try
                [par, keyval, present, filled] = my_func_1 (opt,...
                    'input_file.dat', 18, {'hello','tiger'},...
                    '-back', [15000,19000], 'mod','-nonorm');
            catch ME
                return
            end
        end
        
        %--------------------------------------------------------------------------
        function test_10 (self)
            % Straightforward use, with 'noflag', testing prefix
            % Allow use of prefix, but don't demand it
            
            opt.prefix = '-';
            opt.prefix_req = false;
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                '-back', [15000,19000], 'mod','-nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_11 (self)
            % Test a keyword value also being a string that matches a 
            % keyword. This is valid
            
            opt = [];   % Use default options everywhere
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                'back', 'normalise', 'mod');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background','normalise', ...
                'normalise', true, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', false, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        % Test of prefix and prefix_ctrl
        %--------------------------------------------------------------------------
        function test_pre_1 (self)
            % Test of required prefix
            
            opt.prefix = '-';   % recall opt.prefix_req==true by default
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                '-back', [15000,19000], '-mod','-nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_2  (self)
            % Use a keyword 'back' without the (default) required prefix, so
            % interpreted as a parameter, as is also the following value
            
            opt.prefix = '-';
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                'back', [15000,19000], '-mod','-nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}, 'back', [15000,19000]};
            keyval_ref = struct(...
                'background',[12000,18000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',false, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_3  (self)
            % Test of prefix control character
            
            opt.prefix = '-';
            opt.prefix_ctrl = '\';
            opt.prefix_req = false;
            
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},'\back','\-mod',...
                'back', [15000,19000], '-mod','-nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}, 'back', '-mod'};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_3a  (self)
            % Test of more complex prefix and with a prefix control character
            
            opt.prefix = 'key:';
            opt.prefix_ctrl = '\';
            opt.prefix_req = false;
            
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},'\back','\key:back','-mod',...
                'key:back', [15000,19000], 'key:mod','key:nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}, 'back', 'key:back', '-mod'};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_3b  (self)
            % Test of more complex prefix and with a prefix control character
            
            opt.prefix = 'key:';
            opt.prefix_ctrl = '\';
            opt.prefix_req = true;
            
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},'back','-mod',...
                'key:back', [15000,19000], 'key:mod','key:nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}, 'back', '-mod'};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_4  (self)
            % Test of prefix control character the same as prefix
            % Recall prefix_req==true by default, so valid in this test
            
            opt.prefix = '-';   
            opt.prefix_ctrl = '-';
            
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},'--back','mod',...
                '-back', [15000,19000], '-mod','-nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}, '-back', 'mod'};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_5  (self)
            % Test of prefix control character the same as prefix
            % Set prefix_req==false, so should throw an error
            
            opt.prefix = '-';
            opt.prefix_ctrl = '-';
            opt.prefix_req = 0;
            
            try
                [par, keyval, present, filled] = my_func_1 (opt,...
                    'input_file.dat', 18, {'hello','tiger'},'--back','mod',...
                    '-back', [15000,19000], '-mod','-nonorm');
            catch ME
                return
            end
        end
        
        %--------------------------------------------------------------------------
        function test_pre_6  (self)
            % Test of alternative default options
            
            opt.default = 'dashprefix_noneg';
            
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},'--back','nonorm',...
                '-back', [15000,19000], '-mod','-norm',0);
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}, '-back', 'nonorm'};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_7 (self)
            % Test of default options
            
            opt.default = 'default';   % Use default options everywhere
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                'back', [15000,19000], 'mod','nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
        function test_pre_8 (self)
            % Test of default options
            
            opt.default = '';   % Use default options everywhere
            [par, keyval, present, filled] = my_func_1 (opt,...
                'input_file.dat', 18, {'hello','tiger'},...
                'back', [15000,19000], 'mod','nonorm');
            
            par_ref = {'input_file.dat', 18, {'hello','tiger'}};
            keyval_ref = struct(...
                'background',[15000,19000], ...
                'normalise', false, ...
                'modulation', true, ...
                'output', 'data.txt');
            present_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', false);
            filled_ref = struct(...
                'background',true, ...
                'normalise', true, ...
                'modulation', true, ...
                'output', true);
            
            assertEqual (par_ref, par)
            assertEqual (keyval_ref, keyval)
            assertEqual (present_ref, present)
            assertEqual (filled_ref, filled)
        end
        
        %--------------------------------------------------------------------------
    end
end


%--------------------------------------------------------------------------
function [par, keyval, present, filled] = my_func_1 (opt, varargin)
%
% - Unlimited positional parameters
% - Four keyword/values
% - Two flags
keyval_def = struct(...
    'background',[12000,18000], ...
    'normalise', 1, ...
    'modulation', 0, ...
    'output', 'data.txt');

% Arguments which are logical flags:
flagnames = {'normalise','modulation'};

% Parse input:
if isempty(opt)
    [par, keyval, present, filled] = parse_arguments...
        (varargin, keyval_def, flagnames);
else
    [par, keyval, present, filled] = parse_arguments...
        (varargin, keyval_def, flagnames, opt);
end
end


%--------------------------------------------------------------------------
function [par, keyval, present, filled] = my_func_2 (par_req, par_opt, opt, varargin)
%
% - Numbered or named required and optional positional parameters
% - Four keyword/values
% - Two flags
keyval_def = struct(...
    'background',[12000,18000], ...
    'normalise', 1, ...
    'modulation', 0, ...
    'output', 'data.txt');

% Arguments which are logical flags:
flagnames = {'normalise','modulation'};

% Parse input:
if isempty(opt)
    [par, keyval, present, filled] = parse_arguments...
        (varargin, par_req, par_opt, keyval_def, flagnames);
else
    [par, keyval, present, filled] = parse_arguments...
        (varargin, par_req, par_opt, keyval_def, flagnames, opt);
end
end
